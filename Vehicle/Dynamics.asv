function dvdt = Dynamics(t, vector, vehicle, steeringAngle)
%DYNAMICS Describes all the dynamic equations needed to model a 4 Wheel 
% Vehicle with the Reduced nonlinear double-track method

% Positive rotation is defined by the right hand rule
% Define Vector Values
vx      = vector(1);
vy      = vector(2);
yawRate = vector(3);
ax      = vector(4);
ay      = vector(5);
yawAcc  = vector(6);
omegaRR = vector(7);
omegaRL = vector(8);

%% Calculate forces 
% Vertical Wheel Forces
wheelForces.frontRight.Fz = vehicle.mass*vehicle.wd/2 + vehicle.CoGz*vehicle.mass*ay/2/vehicle.trackFront - vehicle.CoGz*vehicle.mass*ax/2/vehicle.wb;
wheelForces.frontLeft.Fz  = vehicle.mass*vehicle.wd/2 - vehicle.CoGz*vehicle.mass*ay/2/vehicle.trackFront - vehicle.CoGz*vehicle.mass*ax/2/vehicle.wb;
wheelForces.RearRight.Fz  = vehicle.mass*(1-vehicle.wd)/2 + vehicle.CoGz*vehicle.mass*ay/2/vehicle.trackFront + vehicle.CoGz*vehicle.mass*ax/2/vehicle.wb;
wheelForces.RearLeft.Fz   = vehicle.mass*(1-vehicle.wd)/2 - vehicle.CoGz*vehicle.mass*ay/2/vehicle.trackFront + vehicle.CoGz*vehicle.mass*ax/2/vehicle.wb;

% Wheel speeds
speedRR = (vx + yawRate*vehicle.trackRear);
speedRL = (vx - yawRate*vehicle.trackRear);

% Calculate slip ratios
slipFR = 0;
slipFL = 0;
slipRR = vehicle.Reff * omegaRR/speedRR - 1;
slipRL = vehicle.Reff * omegaRL/speedRL - 1;

% Calculate slip angles
slipAngleFR = atan((vy + vehicle.wb * (1-vehicle.wd) * yawRate)/(vx + vehicle.trackFront/2*yawRate)) - steeringAngle;
slipAngleFL = atan((vy + vehicle.wb * (1-vehicle.wd) * yawRate)/(vx - vehicle.trackFront/2*yawRate)) - steeringAngle;
slipAngleRR = atan((vy - vehicle.wb * vehicle.wd * yawRate)/(vx + vehicle.trackRear/2*yawRate));
slipAngleRL = atan((vy - vehicle.wb * vehicle.wd * yawRate)/(vx - vehicle.trackRear/2*yawRate));

% Longitudinal Wheel Forces
wheelForces.frontRight.Fx = F_longit(slipAngleFR, slipFR, wheelForces.frontRight.Fz, 0);
wheelForces.frontLeft.Fx  = F_longit(slipAngleFL, slipFL, wheelForces.frontLeft.Fz, 0);
wheelForces.rearRight.Fx  = F_longit(slipAngleRR, slipRR, wheelForces.rearRight.Fz, 0);
wheelForces.rearLeft.Fx   = F_longit(slipAngleRL, slipRL, wheelForces.rearLeft.Fz, 0);

% Lateral Wheel Forces
wheelForces.frontRight.Fy = F_lateral(slipAngleFR, slipFR, wheelForces.frontRight.Fz, 0);
wheelForces.frontLeft.Fy  = F_lateral(slipAngleFL, slipFL, wheelForces.frontLeft.Fz, 0);
wheelForces.rearRight.Fy  = F_lateral(slipAngleRR, slipRR, wheelForces.rearRight.Fz, 0);
wheelForces.RearLeft.Fy   = F_lateral(slipAngleRL, slipRL, wheelForces.rearLeft.Fz, 0);

% Self Aligning wheel moments (Placeholder)
wheelForces.frontRight.Mz = 0;
wheelForces.frontLeft.Mz  = 0;
wheelForces.RearRight.Mz  = 0;
wheelForces.RearLeft.Mz   = 0;

%% Form Equation System
% Wheel longitudinal force matrix
wheelFxMatrix = [wheelForces.frontRight.Fx;...
                 wheelForces.frontLeft.Fx ;...
                 wheelForces.RearRight.Fx ;...
                 wheelForces.RearLeft.Fx];
% Wheel lateral force matrix
wheelFyMatrix = [wheelForces.frontRight.Fy;...
                 wheelForces.frontLeft.Fy ;...
                 wheelForces.RearRight.Fy ;...
                 wheelForces.RearLeft.Fy];

% Wheel self aligning torque 
wheelMzMatrix = [wheelForces.frontRight.Mz;...
                 wheelForces.frontLeft.Mz ;...
                 wheelForces.RearRight.Mz ;...
                 wheelForces.RearLeft.Mz];

steerAngle = [steeringAngle;...
              steeringAngle;...
              0;...
              0];

% Y-Axis Distance of wheels from the CoG
halfTrack = [-vehicle.trackFront/2;...
              vehicle.trackFront/2;...
             -vehicle.trackRear/2;...
              vehicle.trackRear/2];
% X-Axis Distance of wheels from the CoG
xDistCoG = [ vehicle.wb * (1-vehicle.wd);...
             vehicle.wb * (1-vehicle.wd);...
            -vehicle.wb * vehicle.wd;...
            -vehicle.wb * vehicle.wd];

% Equation system
tempFxVector = wheelFxMatrix.*cos(steerAngle) - wheelFyMatrix.*sin(steerAngle);
tempFyVector = wheelFyMatrix.*cos(steerAngle) + wheelFxMatrix.*sin(steerAngle);

% Longitudinal Acceleration
accelX  = sum(tempFxVector)/vehicle.mass + yawRate.*vy;
% Lateral Acceleration
accelY  = sum(tempFyVector)/vehicle.mass - yawRate.*vx;
% Yaw acceleration
accelJz = (sum(wheelMzMatrix) + sum(tempFyVector.*xDistCoG) + sum(tempFxVector.*halfTrack))/vehicle.InertiaZ;

% Rear wheel angular accelaration
accelJwRR = (TmotorRight - wheelForces.RearRight.Fx)/vehicle.Jw;
accelJwRL = (TmotorLeft - wheelForces.RearLeft.Fx)/vehicle.Jw;

dvdt = [ax; ay; yawAcc; accelX; accelY; accelJz ; accelJwRR, accelJwRL];
end
